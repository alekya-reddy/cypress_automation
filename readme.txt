How to run tests on cypress
----------------------------

To open debugger while you are writing/editing test files, navigate to the Cypress folder (or just open termina in Visual Code), then type into command line: 

npx cypress open 

Then, from the window that opens, double click the file you want to run
If using debugger, you can set your env variables in cypress.json (for example, TEST_ENV=pathfactory-staging)

If you are done editing, and just want to run one specific file, you can type into terminal: 

npx cypress run --env TEST_ENV=pathfactory-qa --browser chrome --spec cypress/integration/new_website_test.js

From above, you can infer that --env allows you To declare whatever env variables you want (env variables must be separated by a comma). 
This is equivalent to declaring env variables in cypress.json, and the way you call it in the test file is the same, eg Cypress.env('TEST_ENV')
Declaring env variables in the command line will overrite whatever is in cypress.json, so you don't have to worry about deleting it from cypress.json when using command line 
You can set whatever browser you want using --browser
You can run whichever file you want using --spec 

To turn off video recording, you can pass in argument --config video=false

eg) npx cypress run --env TEST_ENV=pathfactory-qa --config video=false  --browser chrome --spec cypress/integration/visit_other_domain_test.js




How the cypress repo is organized
---------------------------------

-Use classes to represent the organization of our app
-These classes will contain the links to various parts of the app (content library, settings, target etc)
-These classes will contain the locators to various elements in the app
-These classes will contain any text that we need to check against (like the page titles)
-These classes will contain helper functions

-To use these classes in a test file, build a new page object instance using these classes at beginning of each test file. You can leave blank parameters 
if going with default values for username, login and org, or specific which org, username, password 

-There will be a common class to represent locators, links and helper functions that are accessible or present in all parts of the application. 
-The common class also includes login functions even though these are not common elements to entire app - don't really want to create a seperate class for login 
-For example, the navigation links, the top menu to access org settings, common generic elements such as toggles and checkboxes - these would be part of the common class
-The common class will have children classes representing each webpage of the app. Example, target, recommend, website tools, web ex, org settings, clienthq etc
-Children classes will inherit all properties from the parent common class, so all children classes will have access to the same locators as the common class, just like in the actual application
-Any part of the app that is accessible only from a specific url should be considered part of the same class.
-For example, anything only accessible from https://newqa.pathfactory-qa.com/authoring/content-library/content is considered as part of the content-library class
-Anything that is accessible from all parts of the app, or the same element is present across multiple urls should go into common class
-Use this rule of thumb to decide where a locator should go, or create a new class when the need arises 
-On consumption side, these classes can follow the same organization


Cypress quirks
--------------

-You cannot hover using cypress. You must use a workaround. If an element is only visible by hovering over another element, then use force click.
If you need to see the hover state of an element, use jquery to force it into hover state, as long as this is how the hover state is triggered. 
Cypress has documentation on this. 

-You cannot visit 2 urls with different domains in the same it block. You can visit 2 urls with different domains on a separate it block each. 
However, if you use a beforeEach hook, and you visit a url in the beforeEach, then all it blocks can visit only that same url. 
You can get around this by using an it block as a before hook, and for beforeEach, you'll just have to copy and paste the beforeEach code to each it block. 

-Cypress runs each cy.get command asynchronously. That means you can't save the returned element into a variable to be used later.
You have to work within the callback function. 
-You can do a synchronous version of get by using Cypress.$('selector')
-Note that Cypress reads your test file, places each cy command it comes across into a queue, then when the end of your code is reached, all the 
queued up cy commands will run in the order in which they were generated by your code 
-A useful strategy to take advantage of this is to use cy.get('body'). As long as you are on an html page, this will always immediately return the body 
without taking any time. You can then chain a 'then' off this cy.get('body') and do anything you want inside the 'then', and be
guaranteed that it will all execute before the next cy command. 

-Cypress will fail your test if it detects an uncaught exception error in the browser console. To turn this off, insert

beforeEach(() => {
    cy.log("Before every test in every spec file, prevent Cypress from failing our tests due to uncaught:exception error, which happens a lot in our application.")
    Cypress.on('uncaught:exception', (err, runnable) => {
        return false
    })
})

into the index.js file 

-Cypress modifies app code to turn off what it thinks are useless pieces of code that interfere with Cypress. If this is interfering with your test,
you can turn it off by adding

 "modifyObstructiveCode": false

 to the cypress.json file. 


-You can't use promises in Cypress, or async await to get around its annoying asynchronous nature. Even if you find a workaround,
which I did, if you use any promise whatsoever, it'll completely screw up the order in which cy commands are run... a complete mess 
-Here's what I tried:

hasText(locator, matchText, waitTime){
        cy.log('checking if element has text')
        const executor = (resolve, reject) => {
            let textFound = false;
            let time = 0; 

            const checkText = () => {
                let elemText = Cypress.$(locator).text(); 
                textFound = elemText.includes(matchText); 
                time += 500;
                if (textFound == true){
                    clearInterval();
                    resolve("Text found");
                } else if (time > waitTime) {
                    clearInterval();
                    reject("Text not found");
                }
            }

            setInterval(checkText, 500);
        }

        return new Promise(executor);
   
    }

-Cypress doesn't tell you which line failed, making it much harder to debug. Sure, it shows you snapshots of the webpage at each step, but I don't find that useful honestly...
I prefer to know exactly what line a test fails so that I can pause at that line and inspect the dom manually 



 Cypress useful tips
 -------------------

 See their documentation. Outside of that, here's a list of some useful tips

 -You can set wait times
 eg) cy.get('.my-slow-selector', {timeout: 10000})

 -Cypress wraps its elements in jquery, so you can use jquery to get and manipulate element properties 
 eg. Let's say you have element 'element' 
	element.css(“background-color”)  // This will return value of background-color 
	//.css() is a jquery function 

-You can also use vanilla javascript, but this is a pain as it requires you to get the document first, then work within that document 
eg) cy.document().then((doc)=>{  //write vanilla javascript here to manipulate dom elements   }) 


Conditional Testing Using Element Computed Styles (as in not declared in-line)
To do conditional checking by checking for element properties like background-color, you can get the background-color's value like this: 

cy.get('[data-qa-hook="enableWebsiteJourney"]').then((toggle)=>{
		let color = toggle.css("background-color") 
		if (color == 'rgb(221, 221, 221)'){
		toggle.click()
	}
})


Conditional Testing Using Element Attributes 
If the style, or other attribute is declared in-line like <div style='blah' class='blah' data-qa-hook='blah'>, then you can get the value of that attribute like so: 

cy.get('[data-qa-hook="enableWebsiteJourney"]').invoke('attr', 'data-qa-hook').then((attr)=>{
	cy.log(attr) // This will log the data-qa-hook 
})



Conditional Testing Using Element Text
If you want to get the Element's text for conditional testing, you can do it like this:

cy.get('[data-qa-hook="enableWebsiteJourney"]').invoke('text').then((text)=>{
	cy.log(text) // This will log the text on that element, which is ONOFF
})


Conditional Testing Using Absence/Presence of Element
If you want to something different depending on whether or not an element is present, you can do it like this:

cy.get('button').click()  //This will trigger some change which could do either A or B
cy.get('body').then(($body) => { 
	// synchronously query from body 
	// to find which element was created 
	if ($body.find('input').length) { 
		// if nothing found, length would be zero/undefined, and this is a falsy in javascript 
		return 'input' 
	} 
	// else assume it was textarea 
	return 'textarea' 
}).then((selector) => { 
	// selector is the string that was returned in previous function 
	cy.get(selector).type(`found the element by selector ${selector}`)
})



Using Vanilla Javascript to Manipulate the DOM
If you want to do this, you can try: 

cy.document().then((doc) => {
	//querySelector is vanilla javascript function to find elements 
	let elem = doc.querySelector('[data-qa-hook="enableWebsiteJourney"]')
	
	// getComputedStyle is vanilla js function to get non-in-line styles
	let style = getComputedStyle(elem)
	
	cy.log(style['background-color']) // Will log background color, style is css object 
	if(style['background-color'] == 'rgb(221, 221, 221)'){
		// Do something 
	}
})



When using cy.contains, always specific the element type if want to locate by element text
eg) cy.contains('button', 'button label')
If only do cy.contains('button label'), cypress might locate the lowest ordered element that contains the text, which could end up being a non-clickable span 
<button><span>button label</span></button>



-when using waits inside chained gets or contains, there is potential to fail. I suspect the reason is Cypress will immediately get the 
first set of elements matching the first 'get' before expected change happens, then in the chained contains, 
it will wait on that change from among the found elements. Since elements were pulled from an earlier state, Cypress will not find 
what you're expecting. 
-So if using wait times, make sure to do it all in a single command, not in a chained command 
eg) cy.get('elem').contains('text', {timeout: 10000}) --> potential to fail do this instead:
cy.contains('elem', 'text', {timeout: 10000})



to wait, use cy.wait(timeInMilliseconds)

to pause for debugging, use cy.pause()






How to create function in Cypress that if X is true, do A, else do B, wait up to or less than n seconds for X to be true 
--------------------------------------------------------------------------------------------------------------------------

The above function is a very simple tool useful for conditional testing which Cypress does not provide out of the box. 
In fact, the developers went out of their way to write a long spiel about why conditional testing is bad, and here's how 
you should work around it. Unsurprisingly, they have structured their test framework in such a way that it is very difficult
to do conditional testing. 

First, they do not provide out of the box methods to check for an element or its properties,
which would then evaluate to true or false without making an assertion (causing the test to fail if assertion returns false).
This isn't to say you can't do conditional testing in Cypress - it's just awkward. A workaround is to get the 
Cypress element. Since all Cypress elements are wrapped in jquery, you can then use jquery to get whatever property 
you need out of the element without having to do an assertion that could fail your test. To see if an element exists,
you have to cy.get the entire document, then use jquery to 'find' an element, which returns an array of matching elements. 
Not straightforward, but not too much of a pain either. I can live with this. 

The problem arises when you need to check for a condition but it takes some time for that condition to be true, 
if at all. For example, if you click a button, a specific text might or might not pop up. You don't want to fail the 
test if it doesn't pop up - just do something different depending on whether or not it pops up. I'm not going to 
get into why you would need this type of testing. Cypress developers are adamant you don't ever need to do this. 
I'll just say this: they're wrong, and the fact that they think they know better is very annoying. 

Now, to address the above problem, all you have to do is wait a specific amount of time for the condition 'X' to be 
true, and if true do A, else do B. 

/*cy.wait(2000) // I'd like to avoid arbitrary wait times, but because Cypress doesn't provide ability to wait for a check on an element to return true before returning false, hard waits become necessary
        cy.get(this.antModalBody).invoke('text').then((text)=>{
            if(text.includes('has already been taken')) {
                cy.contains('button', 'Cancel').click()
            }
})*/

While this works, and you can do this in Cypress, it's not ideal because it forces your test to wait the full amount of time. 
If X is true before the wait time is over, I want the test to move on. Unfortunately, there's no built-in method to do this 
in Cypress because Cypress developers have their heads up their a**es. (It's not that they can't give us this - they refuse to).

So... I had to build this function myself. Thus began a long and difficult journey. 

The first obvious way of going about this is to use a loop that contains a wait, which would then evaluate if an element's
condition is true, and break out of loop if true. The problem is that cy commands are asynchronous. In Cypress's 
context, here's what this means: Cypress reads your code and queues up each cy command based on how you wrote 
your code. If you have a loop, the full loop will run before any of the cy commands inside it are run. Thus, if you have 
logic that says 'break out of the loop if true', and the condition is dependent on something returned from a cy command,
then the condition will be false for the entire loop. In essence, you will end up waiting the full amount of time. 

So that won't work. 

The next obvious thing to do would be to generate a javascript promise, then chain a 'then' off the resolved promise. In 
any other universe, this would work, but in Cypress universe, this won't fly. Cypress will straight up fail your test and 
tell you not to use cy commands inside of promises. This pissed me off, so I decided to find a workaround. If I cannot use
cy commands inside a promise, then I won't. That doesn't mean I won't use a promise. I found a way to get an element and 
pull its properties without using a cy command. I put this in a promise. I use this promise in my Cypress test file...

Cypress blew up. 

Yeah, it turns out having any sort of promise in your Cypress code will turn everything upside down. Commands that should
run last are run first, and the order of the cy commands just becomes completely garbled. It's a horrendous mess. 

No wonder they won't allow promises - at all. 

Oh, and don't even bother with using async... await. Cypress doesn't support that either. 

So given all these restrictions, I'm now wondering how the heck do I force Cypress to bloody f***ing wait for condition
X to be true before continuing on with the test? And NO! I refuse to use a hard wait. I can do better than that, and I
will find a way with or without Cypress's help - that's what I told myself. 

I devised a new plan. I would use setTimeOut... inside a loop. 

The idea was that if I delayed generating a cy command, perhaps I could somehow force Cypress to... Yeah, it was a stupid 
idea. First of all, Cypress already provides a wait function, so setTimeout would be unnecessary. Second, it wasn't 
Cypress that I needed to delay (I could use cy.wait)... it was the javascript loop itself I needed to delay. 
I needed the loop to run its internal logic at the same time as the cypress commands contained within - I needed 
the Cypress commands to control whether or not to break out of the loop. But since the loop running and the cy command
execution are decoupled from each other, the loop would have no access to whatever result the cy command spits out. 
setTimeOut would not work beecause it doesn't actually stop the loop - it just causes the code within to run at a later time. 
If that code contains cy commands, then those commands wouldn't even make it into the command queue. Cypress would 
finish reading up all the lines of code I had written, then it would start executing the commands in queue, and once that
happens, no more commands can be entered in to the queue. 

Then I realized I didn't need to break out of the loop. 

Here's the thing about Cypress. Every cy command is put into a queue. Each cy command must finish executing before 
the next one is started. So while it is 'asynchronous' from the rest of my javascript code, with respect to each other, they are synchronous.
Furthermore, Each cy command can contain within it other cy commands, plus accompanying logic. This logic does not 
execute until its parent cy command is started.  

So... I can use a loop to generate a bunch of do-nothing cy commands that contain within them a block of code that checks if a 
condition is true. If true, do something, if false, do something else.

If X is true, do A. 
If X is false, do B (B = wait) 

Hmm... but once X is true, it will do A repeatedly since I generated a bunch of cy commands to do A if X is true. 

But... 

If X is false
    Check if X is true, and if true do A, else wait 
If X is true... do nothing (i.e. DO NOT check if X is true, and DO NOT wait)

So while I can't break out of generating a whole bunch of useless cy commands, the cy command generated by the loop can 
be a simple cy.get('body'). 'body' will always exist on an html page, so it will immediately be found, meaning,
you can have dozens of cy.get('body') without slowing down the test. 

Each cy.get('body') will contain logic to check for X, and as long as X is false, it will perform a check and wait. 
As soon as X is true, there will be no more checks and no more waiting. 

In essence, do A as soon as X is true, and don't wait any longer than that. 

So I can now set the maximum wait time to 20 seconds or as long as I want. My code will not wait the full time. As soon as 
X is true, it will move on. 

Great. Now I want to genericise this function so that I don't have a hard-coded do 'A' if 'X' is true. 

So, the function should return true or false, after a time, and then use that to decide whether or not to do A, which would
exist outside the function. 

So how do I extract the returned value from this function? Not so straightforward as it's an async function in an environment
that does not support promises nor async-await. 

Assigning the called function to a variable is out of the question because the variable would be assigned before the function 
resolves to true or false. 

I decided to pass in an object. The object would be mutated by the function, and thus the original reference to the object
would point to the new value inside the object. I could then access this value outside the function. 

I ran into the same problem. The object value would never be true because I'm doing the condition check before 
the cy commands inside the function have a chance to set the value to true. 

Don't you just love async code?

I solved this problem by putting the condition check for X inside a cy.get('body') command after the function. Again, I don't actually need 
to 'get' the 'body'... that command is only necessary to place whatever code inside of it into the queue so that the code 
executes in the intended order. The function generates a bunch of cy.get('body') commands, each containing a check and wait code
that only runs if X is false. Then, a subsequent cy.get('body') command will containing the logic to check if X is true before
doing A. 

So now I finally have the desired result. I have a generic function that waits for X to be true before doing A. 

... except that it's clunkly and awkward to use. Not a great function. 

elementHasText(locator, textToMatch, waitTime, conditionObject){
        conditionObject.matchFound = 'no';
        for(let i = 0; i <= waitTime; i += 500){
            cy.log("loop i = " + i)
            cy.get('body').then(()=>{
                if(conditionObject.matchFound == 'no'){
                    cy.get(locator).invoke('text').then((text)=>{
                        if(text.includes(textToMatch)){
                            conditionObject.matchFound = true;
                            cy.log(`Match found: ${conditionObject.matchFound}`)
                        } else {
                            cy.wait(500)
                        }
                    })
                }
            })
        }
    }

    /*let conditionObject = {};
        this.elementHasText(this.antModalBody, 'has already been taken', 2000, conditionObject)
        cy.get('body').then(()=>{
            if(conditionObject.matchFound == true){
                cy.log(`Match found, so click the button`)
                cy.contains('button', 'Cancel').click()
            } else if (conditionObject.matchFound == 'no') {
                cy.log(conditionObject.matchFound)
                cy.log(`no match found, so don't click the button`)
            }
    })*/

So instead of trying to extract the value of X out of the function, I decided to pass in a call back function. 

Easy peasy lemon squeazy. 

doIfElementHasText(locator, textToMatch, waitTime, callback){
        let matchFound = false;
        for(let i = 0; i <= waitTime; i += 500){
            cy.get('body', {log: false}).then((body)=>{
                if(!matchFound && body.find(locator).length > 0){
                    cy.get(locator, {log: false}).invoke('text').then((text)=>{
                        if(text.includes(textToMatch)){
                            matchFound = true;
                            callback();
                        } else {
                            cy.wait(500, {log: false})
                        }
                    })
                }
            })
        }
    }

    this.doIfElementHasText(this.antModalBody, 'has already been taken', 10000, ()=>{
            cy.contains('button', 'Cancel').click()
        })




